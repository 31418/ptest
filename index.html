<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Pathfinding Learning Website</title>

<style>
body {
  font-family: Arial, sans-serif;
  margin: 0;
  display: flex;
  height: 100vh;
}
#sidebar {
  width: 250px;
  background-color: #2c3e50;
  color: #ecf0f1;
  padding: 20px;
  overflow-y: auto;
}
.question-item {
  padding: 10px;
  margin-bottom: 5px;
  border-radius: 5px;
  cursor: pointer;
}
.question-item.locked {
  opacity: 0.5;
  cursor: not-allowed;
}
.question-item.active {
  background-color: #2980b9;
}
.question-item.completed {
  background-color: #27ae60;
}
#main {
  flex: 1;
  padding: 40px;
}
.answer-btn {
  display: block;
  padding: 10px;
  margin: 10px 0;
  background-color: #3498db;
  color: white;
  border: none;
  border-radius: 5px;
  cursor: pointer;
}
.answer-btn.correct {
  background-color: #27ae60;
}
.answer-btn.incorrect {
  background-color: #c0392b;
}
#next-btn {
  margin-top: 20px;
  padding: 10px 20px;
  background-color: #f39c12;
  border: none;
  border-radius: 5px;
  color: white;
  display: none;
  cursor: pointer;
}
.match-container {
  display: flex;
  gap: 40px;
}
.match-item {
  padding: 8px;
  background: #ecf0f1;
  margin-bottom: 5px;
  cursor: pointer;
  border-radius: 5px;
}
.selected {
  background: #f1c40f;
}
canvas {
  border: 2px solid #333;
  margin-top: 20px;
}
</style>
</head>

<body>

<div id="sidebar">
  <h2>Questions</h2>
  <div id="question-list"></div>
</div>

<div id="main">
  <h1 id="question-title"></h1>
  <p id="question-text"></p>
  <div id="answers"></div>
  <button id="next-btn">Next Question</button>
</div>

<script>
/* ======================
   QUESTIONS
====================== */

const questions = [
  {
    type: "matching",
    title: "Match Pathfinding Terms",
    text: "Match each term with its correct definition.",
    left: ["A", "B", "C", "D"],
    right: ["Point graph", "Grid graph", "Hexagonal grid", "NavMesh"],
    correctMatches: {
      A: "Grid graph",
      B: "Hexagonal grid",
      C: "Point graph",
      D: "NavMesh"
    }
  },

  {
    type: "multiple-choice",
    title: "Calculate Distance",
    text: "How long will the path be for Euclidean and Manhattan distance?",
    options: [
      { text: "e: 11.14, m: 16", correct: true },
      { text: "e: 13.63, m: 13", correct: false },
      { text: "e: 12.04, m: 17", correct: false }
    ]
  },

  {
    type: "order",
    title: "Pathfinding Steps",
    text: "Put the steps of a pathfinding algorithm in the correct order.",
    items: [
      "Reconstruct the final path",
      "Select the node with the lowest cost",
      "Start at starting node",
      "For the selected node, create 4 children nodes"
    ],
    correctOrder: [
      "Start at starting node",
      "Select the node with the lowest cost",
      "For the selected node, create 4 children nodes",
      "Reconstruct the final path"
    ]
  },

  {
    type: "grid",
    title: "Grid Path Drawing",
    text: "Draw a path from Start (green) to End (red). Avoid black squares."
  },

  {
    type: "randomizer",
    title: "Random Pathfinding Question",
    text: "Answer the randomly selected question.",
    pool: [
      {
        text: "Which algorithm guarantees the shortest path?",
        options: [
          { text: "DFS", correct: false },
          { text: "BFS", correct: true },
          { text: "Greedy Best First", correct: false }
        ]
      },
      {
        text: "Which algorithm uses heuristics?",
        options: [
          { text: "Dijkstra", correct: false },
          { text: "A*", correct: true },
          { text: "BFS", correct: false }
        ]
      },
      {
        text: "Which graph type uses weights?",
        options: [
          { text: "Tree", correct: false },
          { text: "Weighted graph", correct: true },
          { text: "Unweighted graph", correct: false }
        ]
      }
    ]
  }
];

/* ======================
   APP STATE
====================== */

let currentQuestionIndex = 0;
const progress = Array(questions.length).fill(false);

const questionListEl = document.getElementById("question-list");
const questionTitleEl = document.getElementById("question-title");
const questionTextEl = document.getElementById("question-text");
const answersEl = document.getElementById("answers");
const nextBtn = document.getElementById("next-btn");

/* ======================
   SIDEBAR
====================== */

function renderQuestionList() {
  questionListEl.innerHTML = "";
  questions.forEach((q, i) => {
    const div = document.createElement("div");
    div.textContent = `${i + 1}. ${q.title}`;
    div.className = "question-item";
    if (i > 0 && !progress[i - 1]) div.classList.add("locked");
    if (i === currentQuestionIndex) div.classList.add("active");
    if (progress[i]) div.classList.add("completed");
    div.onclick = () => {
      if (i === 0 || progress[i - 1]) {
        currentQuestionIndex = i;
        renderQuestion();
      }
    };
    questionListEl.appendChild(div);
  });
}

/* ======================
   RENDER QUESTION
====================== */

function renderQuestion() {
  renderQuestionList();
  answersEl.innerHTML = "";
  nextBtn.style.display = "none";

  const q = questions[currentQuestionIndex];
  questionTitleEl.textContent = q.title;
  questionTextEl.textContent = q.text;

  if (q.type === "matching") renderMatching(q);
  if (q.type === "multiple-choice") renderMC(q);
  if (q.type === "order") renderOrder(q);
  if (q.type === "grid") renderGrid();
  if (q.type === "randomizer") renderRandomizer(q);
}

/* ======================
   MATCHING
====================== */

let selectedLeft = null;
let matches = {};

function renderMatching(q) {
  matches = {};
  selectedLeft = null;

  const container = document.createElement("div");
  container.className = "match-container";

  const leftCol = document.createElement("div");
  const rightCol = document.createElement("div");

  q.left.forEach(item => {
    const div = document.createElement("div");
    div.className = "match-item";
    div.textContent = item;
    div.onclick = () => {
      selectedLeft = item;
      document.querySelectorAll(".match-item").forEach(e => e.classList.remove("selected"));
      div.classList.add("selected");
    };
    leftCol.appendChild(div);
  });

  q.right.forEach(item => {
    const div = document.createElement("div");
    div.className = "match-item";
    div.textContent = item;
    div.onclick = () => {
      if (selectedLeft) {
        matches[selectedLeft] = item;
        div.style.background = "#2ecc71";
        selectedLeft = null;
      }
      if (Object.keys(matches).length === q.left.length) checkMatching(q);
    };
    rightCol.appendChild(div);
  });

  container.appendChild(leftCol);
  container.appendChild(rightCol);
  answersEl.appendChild(container);
}

function checkMatching(q) {
  const correct = Object.keys(q.correctMatches).every(
    k => q.correctMatches[k] === matches[k]
  );

  if (correct) {
    alert("Correct!");
    progress[currentQuestionIndex] = true;
    nextBtn.style.display = "inline-block";
    renderQuestionList();
  } else {
    alert("Some matches are incorrect.");
  }
}

/* ======================
   ORDER
====================== */

function renderOrder(q) {
  let currentOrder = [...q.items];
  const container = document.createElement("div");

  function redraw() {
    container.innerHTML = "";
    currentOrder.forEach((item, index) => {
      const div = document.createElement("div");
      div.className = "match-item";
      div.textContent = item;

      const up = document.createElement("button");
      up.textContent = "↑";
      up.onclick = () => {
        if (index > 0) {
          [currentOrder[index - 1], currentOrder[index]] =
          [currentOrder[index], currentOrder[index - 1]];
          redraw();
        }
      };

      const down = document.createElement("button");
      down.textContent = "↓";
      down.onclick = () => {
        if (index < currentOrder.length - 1) {
          [currentOrder[index + 1], currentOrder[index]] =
          [currentOrder[index], currentOrder[index + 1]];
          redraw();
        }
      };

      div.appendChild(up);
      div.appendChild(down);
      container.appendChild(div);
    });
  }

  redraw();
  answersEl.appendChild(container);

  const checkBtn = document.createElement("button");
  checkBtn.className = "answer-btn";
  checkBtn.textContent = "Check Order";

  checkBtn.onclick = () => {
    const correct = q.correctOrder.every((item, i) => item === currentOrder[i]);
    if (correct) {
      alert("Correct order!");
      progress[currentQuestionIndex] = true;
      nextBtn.style.display = "inline-block";
      renderQuestionList();
    } else {
      alert("Incorrect order.");
    }
  };

  answersEl.appendChild(checkBtn);
}

/* ======================
   GRID
====================== */

function renderGrid() {
  const canvas = document.createElement("canvas");
  const size = 10;
  const cell = 40;
  canvas.width = canvas.height = size * cell;
  answersEl.appendChild(canvas);

  const ctx = canvas.getContext("2d");
  const blocked = [[3,3],[3,4],[3,5],[5,5],[6,5],[7,5]];

  let drawing = false;
  let pathOrder = 0;
  const drawn = [];

  function drawGrid() {
    for (let y=0;y<size;y++){
      for (let x=0;x<size;x++){
        ctx.strokeRect(x*cell,y*cell,cell,cell);
        if(blocked.some(b=>b[0]===x && b[1]===y)){
          ctx.fillStyle="black";
          ctx.fillRect(x*cell,y*cell,cell,cell);
        }
      }
    }
    ctx.fillStyle="green"; ctx.fillRect(0,0,cell,cell);
    ctx.fillStyle="red"; ctx.fillRect(9*cell,9*cell,cell,cell);
  }

  drawGrid();

  canvas.onmousedown = () => drawing = true;
  canvas.onmouseup = () => drawing = false;

  canvas.onmousemove = e => {
    if (!drawing) return;
    const rect = canvas.getBoundingClientRect();
    const x = Math.floor((e.clientX - rect.left)/cell);
    const y = Math.floor((e.clientY - rect.top)/cell);

    if (blocked.some(b=>b[0]===x && b[1]===y)) return;
    if (drawn.some(d=>d[0]===x && d[1]===y)) return;

    pathOrder++;
    drawn.push([x,y]);
    const ratio = Math.min(pathOrder/100,1);
    ctx.fillStyle = `rgb(0,${Math.floor(255*ratio)},${Math.floor(255*(1-ratio))})`;
    ctx.fillRect(x*cell,y*cell,cell,cell);
  };

  const finishBtn = document.createElement("button");
  finishBtn.textContent = "Finish Drawing";
  finishBtn.className = "answer-btn";
  finishBtn.onclick = () => {
    progress[currentQuestionIndex] = true;
    nextBtn.style.display = "inline-block";
    renderQuestionList();
  };

  answersEl.appendChild(finishBtn);
}

/* ======================
   RANDOMIZER
====================== */

function renderRandomizer(q) {
  const selected = q.pool[Math.floor(Math.random() * q.pool.length)];
  questionTextEl.textContent = selected.text;

  [...selected.options].sort(() => Math.random() - 0.5).forEach(opt => {
    const btn = document.createElement("button");
    btn.className = "answer-btn";
    btn.textContent = opt.text;
    btn.onclick = () => {
      if (opt.correct) {
        btn.classList.add("correct");
        progress[currentQuestionIndex] = true;
        nextBtn.style.display = "inline-block";
      } else {
        btn.classList.add("incorrect");
      }
      renderQuestionList();
    };
    answersEl.appendChild(btn);
  });
}

/* ======================
   MC
====================== */

function renderMC(q) {
  q.options.forEach(opt => {
    const btn = document.createElement("button");
    btn.className = "answer-btn";
    btn.textContent = opt.text;
    btn.onclick = () => {
      if (opt.correct) {
        btn.classList.add("correct");
        progress[currentQuestionIndex] = true;
        nextBtn.style.display = "inline-block";
      } else {
        btn.classList.add("incorrect");
      }
      renderQuestionList();
    };
    answersEl.appendChild(btn);
  });
}

/* ======================
   NEXT
====================== */

nextBtn.onclick = () => {
  currentQuestionIndex++;
  renderQuestion();
};

renderQuestion();
</script>
</body>
</html>


